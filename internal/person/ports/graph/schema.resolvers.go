package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.37

import (
	"context"
	"fmt"

	appmodel "github.com/alukart32/effective-mobile-test-task/internal/person/model"
	"github.com/alukart32/effective-mobile-test-task/internal/person/ports/graph/generated"
	"github.com/alukart32/effective-mobile-test-task/internal/person/ports/graph/model"
	"github.com/alukart32/effective-mobile-test-task/internal/pkg/zerologx"
	"github.com/rs/zerolog"
)

// CreatePerson is the resolver for the CreatePerson field.
func (r *mutationResolver) CreatePerson(ctx context.Context, input model.CreatePersonInput) (*model.CreatePersonResponse, error) {
	logger := zerologx.Get().With().Ctx(ctx).Logger()
	logger.UpdateContext(func(c zerolog.Context) zerolog.Context {
		return c.Str("port", "graph").Str("op", "create person")
	})

	fio, err := appmodel.NewFIO(input.Name, input.Surname, input.Patronymic)
	if err != nil {
		logger.Err(err).Send()
		return nil, fmt.Errorf("create person: %w", err)
	}
	logger.Info().Object("param", fio).Msg(">> create person")

	personId, err := r.PersonManager.CreateFrom(ctx, fio)
	if err != nil {
		logger.Err(err).Send()
		return nil, fmt.Errorf("create person: %w", err)
	}
	logger.Info().Str("person_id", personId).Msg("<< create person")

	return &model.CreatePersonResponse{
		Success:  true,
		PersonID: personId,
	}, nil
}

// UpdatePerson is the resolver for the UpdatePerson field.
func (r *mutationResolver) UpdatePerson(ctx context.Context, input model.UpdatePersonInput) (*model.UpdatePersonResponse, error) {
	metaData := appmodel.PersonalMetaData{
		Nation: *input.NewNation,
		Gender: *input.NewGender,
		Age:    *input.NewAge,
	}

	logger := zerologx.Get().With().Ctx(ctx).Logger()
	logger.UpdateContext(func(c zerolog.Context) zerolog.Context {
		return c.Str("port", "graph").
			Str("op", "update person").
			Dict("params", zerolog.Dict().
				Str("id", input.PersonID).
				Object("meta", metaData),
			)
	})
	logger.Info().Msg(">> update person")

	if err := r.PersonManager.Update(ctx, input.PersonID, metaData); err != nil {
		logger.Err(err).Send()
		return nil, fmt.Errorf("update person: %w", err)
	}
	logger.Info().Str("status", "ok").Msg("<< update person")

	return &model.UpdatePersonResponse{Success: true}, nil
}

// DeletePerson is the resolver for the DeletePerson field.
func (r *mutationResolver) DeletePerson(ctx context.Context, input model.DeletePersonInput) (*model.DeletePersonResponse, error) {
	logger := zerologx.Get().With().Ctx(ctx).Logger()
	logger.UpdateContext(func(c zerolog.Context) zerolog.Context {
		return c.Str("port", "graph").
			Str("op", "delete person").
			Str("param", input.PersonID)
	})
	logger.Info().Msg(">> delete person")

	if err := r.PersonManager.Delete(ctx, input.PersonID); err != nil {
		logger.Err(err).Send()
		return nil, fmt.Errorf("delete person: %w", err)
	}
	logger.Info().Str("status", "ok").Msg("<< delete person")

	return &model.DeletePersonResponse{Success: true}, nil
}

// GetAllPersons is the resolver for the GetAllPersons field.
func (r *queryResolver) GetAllPersons(ctx context.Context) ([]*model.Person, error) {
	logger := zerologx.Get().With().Ctx(ctx).Logger()
	logger.UpdateContext(func(c zerolog.Context) zerolog.Context {
		return c.Str("port", "graph").
			Str("op", "get all persons")
	})
	logger.Info().Msg(">> get all persons")
	persons, err := r.PersonManager.Collect(ctx, appmodel.PersonFilter{}, 0, 0)
	if err != nil {
		logger.Err(err).Send()
		return nil, fmt.Errorf("get all persons: %w", err)
	}
	logger.Info().Str("status", "ok").Msg("<< get all persons")

	list := make([]*model.Person, len(persons))
	for i, p := range persons {
		list[i] = &model.Person{
			ID:         p.Id,
			Name:       p.Name,
			Surname:    p.Surname,
			Patronymic: p.Patronymic,
			Nation:     p.Nation,
			Gender:     p.Gender,
			Age:        p.Age,
		}
	}
	return list, nil
}

// CollectPersons is the resolver for the CollectPersons field.
func (r *queryResolver) CollectPersons(ctx context.Context, limit *int, offset *int, filter *model.CollectPersonsFilter) ([]*model.Person, error) {
	var (
		resultLimit  int
		resultOffset int
	)
	if limit != nil {
		resultLimit = *limit
	}
	if offset != nil {
		resultOffset = *offset
	}

	var personFilter appmodel.PersonFilter
	if filter != nil {
		personFilter = appmodel.PersonFilter{
			OlderThan:   *filter.OlderThan,
			YoungerThan: *filter.YoungerThan,
			Gender:      *filter.Gender,
			Nations:     filter.Nations,
		}
	}

	logger := zerologx.Get().With().Ctx(ctx).Logger()
	logger.UpdateContext(func(c zerolog.Context) zerolog.Context {
		return c.Str("port", "graph").
			Str("op", "collect persons").
			Dict("params", zerolog.Dict().
				Int("limit", resultLimit).
				Int("offset", resultOffset).
				Object("filters", personFilter),
			)
	})
	logger.Info().Msg(">> collect persons")

	persons, err := r.PersonManager.Collect(ctx, personFilter, resultLimit, resultOffset)
	if err != nil {
		logger.Err(err).Send()
		return nil, fmt.Errorf("collect persons: %w", err)
	}
	logger.Info().Str("status", "ok").Msg("<< collect persons")

	list := make([]*model.Person, len(persons))
	for i, p := range persons {
		list[i] = &model.Person{
			ID:         p.Id,
			Name:       p.Name,
			Surname:    p.Surname,
			Patronymic: p.Patronymic,
			Nation:     p.Nation,
			Gender:     p.Gender,
			Age:        p.Age,
		}
	}
	return list, nil
}

// FindByID is the resolver for the FindById field.
func (r *queryResolver) FindByID(ctx context.Context, personID string) (*model.Person, error) {
	logger := zerologx.Get().With().Ctx(ctx).Logger()
	logger.UpdateContext(func(c zerolog.Context) zerolog.Context {
		return c.Str("port", "graph").
			Str("op", "find person by id").
			Str("param", personID)
	})
	logger.Info().Msg(">> find person")

	person, err := r.PersonManager.FindById(ctx, personID)
	if err != nil {
		logger.Err(err).Send()
		return nil, fmt.Errorf("find person by id: %w", err)
	}
	logger.Info().Str("status", "ok").Object("person", person).Msg("<< find person")

	return &model.Person{
		ID:         person.Id,
		Name:       person.Name,
		Surname:    person.Surname,
		Patronymic: person.Patronymic,
		Nation:     person.Nation,
		Gender:     person.Gender,
		Age:        person.Age,
	}, nil
}

// Mutation returns generated.MutationResolver implementation.
func (r *Resolver) Mutation() generated.MutationResolver { return &mutationResolver{r} }

// Query returns generated.QueryResolver implementation.
func (r *Resolver) Query() generated.QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
